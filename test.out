LP> :load prelude.lp
Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Solved metas:

Interpreter for lambda-Pi.
Type :? for help.
id :: Pi (xx_ : Set) (xx_ -> xx_)
const :: Pi (xx_ : Set) (Pi (yy_ : Set) (xx_ -> yy_ -> xx_))
plus :: Nat -> Nat -> Nat
pred :: Nat -> Nat
natFold :: Pi (xx_ : Set) (xx_ -> (xx_ -> xx_) -> Nat -> xx_)
nat1Elim :: Pi (xx_ : Nat -> Set) (xx_ 0 -> xx_ S( 0 ) -> (Pi (local3_1 : Nat) (xx_ S( local3_1 ) -> xx_ S( S( local3_1 ) ))) -> Pi (local4_ : Nat) (xx_ local4_))
nat2Elim :: Pi (xx_ : Nat -> Set) (xx_ 0 -> xx_ S( 0 ) -> xx_ S( S( 0 ) ) -> (Pi (local4_1 : Nat) (xx_ S( S( local4_1 ) ) -> xx_ S( S( S( local4_1 ) ) ))) -> Pi (local5_ : Nat) (xx_ local5_))
inc :: Nat -> Nat
myFinElim :: Pi (finT_m : Pi (finm_n : Nat) ((Fin  finm_n) -> Set)) ((Pi (finmz_n : Nat) (finT_m S( finmz_n ) (FZero  finmz_n))) -> (Pi (finms_n : Nat) (Pi (finms_f : (Fin  finms_n)) (finT_m finms_n finms_f -> finT_m S( finms_n ) (FS( finms_n , finms_f ))))) -> Pi (finRet_n : Nat) (Pi (finRet_f : (Fin  finRet_n)) (finT_m finRet_n finRet_f)))
finNat :: Pi (finRet_n : Nat) ((Fin  finRet_n) -> Nat)
Unit :: Set
U :: (Fin  S( 0 ))
unitElim :: Pi (xx_ : (Fin  S( 0 )) -> Set) (xx_ (FZero  0) -> Pi (zz_ : (Fin  S( 0 ))) (xx_ zz_))
Void :: Set
voidElim :: Pi (xx_ : (Fin  0) -> Set) (Pi (yy_ : (Fin  0)) (xx_ yy_))
Bool :: Set
False :: (Fin  S( S( 0 ) ))
True :: (Fin  S( S( 0 ) ))
boolElim :: Pi (xx_ : (Fin  S( S( 0 ) )) -> Set) (xx_ (FZero  S( 0 )) -> xx_ (FS( S( 0 ) , (FZero  0) )) -> Pi (local3_ : (Fin  S( S( 0 ) ))) (xx_ local3_))
not :: (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) ))
and :: (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) ))
or :: (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) ))
iff :: (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) ))
xor :: (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) )) -> (Fin  S( S( 0 ) ))
even :: Nat -> (Fin  S( S( 0 ) ))
odd :: Nat -> (Fin  S( S( 0 ) ))
isZero :: Nat -> (Fin  S( S( 0 ) ))
isSucc :: Nat -> (Fin  S( S( 0 ) ))
natEq :: Nat -> Nat -> (Fin  S( S( 0 ) ))
Prop :: (Fin  S( S( 0 ) )) -> Set
pNatEqRefl :: Pi (xx_ : Nat) (xx_ (NatElim ((\ xx_1 . Nat -> (Fin  S( S( 0 ) )))) ((\ nat_k . nat_k (NatElim ((\ xx_1 . (Fin  S( S( 0 ) )))) ((FS( S( 0 ) , (FZero  0) ))) ((\ xx_1 yy_ . (FZero  S( 0 ))))))) ((\ xx_1 yy_ nat_k . nat_k (NatElim ((\ zz_ . (Fin  S( S( 0 ) )))) ((FZero  S( 0 ))) ((\ zz_ local3_ . yy_ zz_)))))) xx_ (FinElim ((\ nat_k . nat_k (NatElim ((\ local3_ . (Fin  local3_) -> Set)) ((\ local3_ . (Fin  S( 0 )))) ((\ local4_ local5_ . local4_ (NatElim ((\ local6_ . (Fin  S( local6_ )) -> Set)) ((\ local3_ . (Fin  S( 0 )))) ((\ local5_1 local6_ . local5_1 (NatElim ((\ local7_ . (Fin  S( S( local7_ ) )) -> Set)) ((\ local3_ . Set)) ((\ local3_ local4_1 local5_2 . (Fin  S( 0 ))))))))))))) ((\ nat_k . nat_k (NatElim ((\ local3_ . local3_ (NatElim ((\ local4_ . (Fin  S( local4_ )) -> Set)) ((\ local4_ . (Fin  S( 0 )))) ((\ local4_ local5_ . local4_ (NatElim ((\ local6_ . (Fin  S( S( local6_ ) )) -> Set)) ((\ local4_1 . Set)) ((\ local4_1 local5_1 local6_ . (Fin  S( 0 )))))))) (FZero  local3_))) ((FZero  0)) ((\ local4_ local5_ . local4_ (NatElim ((\ local6_ . local6_ (NatElim ((\ local6_1 . (Fin  S( S( local6_1 ) )) -> Set)) ((\ local4_1 . Set)) ((\ local4_1 local5_1 local6_1 . (Fin  S( 0 ))))) (FZero  S( local6_ )))) ((Fin  0)) ((\ local3_ local4_1 . (FZero  0))))))))) ((\ local3_ local4_ local5_ . local4_ (FinElim ((\ local6_ local7_ . local6_ (NatElim ((\ local8_ . (Fin  S( local8_ )) -> Set)) ((\ local8_ . (Fin  S( 0 )))) ((\ local4_1 local5_1 . local4_1 (NatElim ((\ local6_1 . (Fin  S( S( local6_1 ) )) -> Set)) ((\ local8_ . Set)) ((\ local8_ local9_ local10_ . (Fin  S( 0 )))))))) (FS( local6_ , local7_ )))) ((\ nat_k . nat_k (NatElim ((\ local6_ . local6_ (NatElim ((\ local7_ . (Fin  S( S( local7_ ) )) -> Set)) ((\ local7_ . Set)) ((\ local7_ local8_ local9_ . (Fin  S( 0 ))))) (FS( S( local6_ ) , (FZero  local6_) )))) ((Fin  S( 0 ))) ((\ local6_ local7_ . (FZero  0)))))) ((\ local6_ local7_ local8_ . local7_ (FinElim ((\ local9_ local10_ . local9_ (NatElim ((\ local11_ . (Fin  S( S( local11_ ) )) -> Set)) ((\ local11_ . Set)) ((\ local11_ local12_ local13_ . (Fin  S( 0 ))))) (FS( S( local9_ ) , (FS( local9_ , local10_ )) )))) ((\ local9_ . (FZero  0))) ((\ local9_ local10_ local11_ . (FZero  0))) (local6_)))) (local3_)))) (S( S( 0 ) ))))
Not :: Set -> Set
leibniz :: Pi (xx_ : Set) (Pi (yy_ : Set) (Pi (zz_ : xx_ -> yy_) (Pi (local3_ : xx_) (Pi (local4_ : xx_) (Eq xx_ local3_ local4_ -> Eq yy_ zz_ local3_ zz_ local4_)))))
symm :: Pi (xx_ : Set) (Pi (yy_ : xx_) (Pi (zz_ : xx_) (Eq xx_ yy_ zz_ -> Eq xx_ zz_ yy_)))
tran :: Pi (xx_ : Set) (Pi (yy_ : xx_) (Pi (zz_ : xx_) (Pi (local3_ : xx_) (Eq xx_ yy_ zz_ -> Eq xx_ zz_ local3_ -> Eq xx_ yy_ local3_))))
apply :: Pi (xx_ : Set) (Pi (yy_ : Set) (Eq Set xx_ yy_ -> xx_ -> yy_))
p1IsNot0 :: Eq Nat S( 0 ) 0 -> (Fin  0)
p0IsNot1 :: Eq Nat 0 S( 0 ) -> (Fin  0)
p0IsNoSucc :: Pi (natT_n : Nat) (Eq Nat 0 S( natT_n ) -> (Fin  0))
replicate :: Pi (xx_ : Nat) (Pi (yy_ : Set) (yy_ -> Vec yy_ xx_))
replicate' :: Pi (xx_ : Set) (Pi (yy_ : Nat) (xx_ -> Vec xx_ yy_))
fromto :: Pi (natT_n : Nat) Vec Nat natT_n
lambda-pi-constraint: src/PatternUnify/Tm.hs:(300,1)-(321,47): Non-exhaustive patterns in function etaContract

